// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/zibbp/eos/ent/channel"
	"github.com/zibbp/eos/ent/chapter"
	"github.com/zibbp/eos/ent/comment"
	"github.com/zibbp/eos/ent/playback"
	"github.com/zibbp/eos/ent/predicate"
	"github.com/zibbp/eos/ent/video"
	"github.com/zibbp/eos/internal/utils"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChannel  = "Channel"
	TypeChapter  = "Chapter"
	TypeComment  = "Comment"
	TypePlayback = "Playback"
	TypeVideo    = "Video"
)

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	description         *string
	image_path          *string
	generate_thumbnails *bool
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	videos              map[string]struct{}
	removedvideos       map[string]struct{}
	clearedvideos       bool
	done                bool
	oldValue            func(context.Context) (*Channel, error)
	predicates          []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id string) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Channel entities.
func (m *ChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ChannelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChannelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChannelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[channel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChannelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[channel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChannelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, channel.FieldDescription)
}

// SetImagePath sets the "image_path" field.
func (m *ChannelMutation) SetImagePath(s string) {
	m.image_path = &s
}

// ImagePath returns the value of the "image_path" field in the mutation.
func (m *ChannelMutation) ImagePath() (r string, exists bool) {
	v := m.image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePath returns the old "image_path" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldImagePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePath: %w", err)
	}
	return oldValue.ImagePath, nil
}

// ClearImagePath clears the value of the "image_path" field.
func (m *ChannelMutation) ClearImagePath() {
	m.image_path = nil
	m.clearedFields[channel.FieldImagePath] = struct{}{}
}

// ImagePathCleared returns if the "image_path" field was cleared in this mutation.
func (m *ChannelMutation) ImagePathCleared() bool {
	_, ok := m.clearedFields[channel.FieldImagePath]
	return ok
}

// ResetImagePath resets all changes to the "image_path" field.
func (m *ChannelMutation) ResetImagePath() {
	m.image_path = nil
	delete(m.clearedFields, channel.FieldImagePath)
}

// SetGenerateThumbnails sets the "generate_thumbnails" field.
func (m *ChannelMutation) SetGenerateThumbnails(b bool) {
	m.generate_thumbnails = &b
}

// GenerateThumbnails returns the value of the "generate_thumbnails" field in the mutation.
func (m *ChannelMutation) GenerateThumbnails() (r bool, exists bool) {
	v := m.generate_thumbnails
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerateThumbnails returns the old "generate_thumbnails" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldGenerateThumbnails(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerateThumbnails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerateThumbnails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerateThumbnails: %w", err)
	}
	return oldValue.GenerateThumbnails, nil
}

// ResetGenerateThumbnails resets all changes to the "generate_thumbnails" field.
func (m *ChannelMutation) ResetGenerateThumbnails() {
	m.generate_thumbnails = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddVideoIDs adds the "videos" edge to the Video entity by ids.
func (m *ChannelMutation) AddVideoIDs(ids ...string) {
	if m.videos == nil {
		m.videos = make(map[string]struct{})
	}
	for i := range ids {
		m.videos[ids[i]] = struct{}{}
	}
}

// ClearVideos clears the "videos" edge to the Video entity.
func (m *ChannelMutation) ClearVideos() {
	m.clearedvideos = true
}

// VideosCleared reports if the "videos" edge to the Video entity was cleared.
func (m *ChannelMutation) VideosCleared() bool {
	return m.clearedvideos
}

// RemoveVideoIDs removes the "videos" edge to the Video entity by IDs.
func (m *ChannelMutation) RemoveVideoIDs(ids ...string) {
	if m.removedvideos == nil {
		m.removedvideos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.videos, ids[i])
		m.removedvideos[ids[i]] = struct{}{}
	}
}

// RemovedVideos returns the removed IDs of the "videos" edge to the Video entity.
func (m *ChannelMutation) RemovedVideosIDs() (ids []string) {
	for id := range m.removedvideos {
		ids = append(ids, id)
	}
	return
}

// VideosIDs returns the "videos" edge IDs in the mutation.
func (m *ChannelMutation) VideosIDs() (ids []string) {
	for id := range m.videos {
		ids = append(ids, id)
	}
	return
}

// ResetVideos resets all changes to the "videos" edge.
func (m *ChannelMutation) ResetVideos() {
	m.videos = nil
	m.clearedvideos = false
	m.removedvideos = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.description != nil {
		fields = append(fields, channel.FieldDescription)
	}
	if m.image_path != nil {
		fields = append(fields, channel.FieldImagePath)
	}
	if m.generate_thumbnails != nil {
		fields = append(fields, channel.FieldGenerateThumbnails)
	}
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldName:
		return m.Name()
	case channel.FieldDescription:
		return m.Description()
	case channel.FieldImagePath:
		return m.ImagePath()
	case channel.FieldGenerateThumbnails:
		return m.GenerateThumbnails()
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldDescription:
		return m.OldDescription(ctx)
	case channel.FieldImagePath:
		return m.OldImagePath(ctx)
	case channel.FieldGenerateThumbnails:
		return m.OldGenerateThumbnails(ctx)
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case channel.FieldImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePath(v)
		return nil
	case channel.FieldGenerateThumbnails:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerateThumbnails(v)
		return nil
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldDescription) {
		fields = append(fields, channel.FieldDescription)
	}
	if m.FieldCleared(channel.FieldImagePath) {
		fields = append(fields, channel.FieldImagePath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldDescription:
		m.ClearDescription()
		return nil
	case channel.FieldImagePath:
		m.ClearImagePath()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldDescription:
		m.ResetDescription()
		return nil
	case channel.FieldImagePath:
		m.ResetImagePath()
		return nil
	case channel.FieldGenerateThumbnails:
		m.ResetGenerateThumbnails()
		return nil
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.videos != nil {
		edges = append(edges, channel.EdgeVideos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.videos))
		for id := range m.videos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvideos != nil {
		edges = append(edges, channel.EdgeVideos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.removedvideos))
		for id := range m.removedvideos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvideos {
		edges = append(edges, channel.EdgeVideos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeVideos:
		return m.clearedvideos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeVideos:
		m.ResetVideos()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ChapterMutation represents an operation that mutates the Chapter nodes in the graph.
type ChapterMutation struct {
	config
	op            Op
	typ           string
	id            *string
	title         *string
	start_time    *float64
	addstart_time *float64
	end_time      *float64
	addend_time   *float64
	clearedFields map[string]struct{}
	video         *string
	clearedvideo  bool
	done          bool
	oldValue      func(context.Context) (*Chapter, error)
	predicates    []predicate.Chapter
}

var _ ent.Mutation = (*ChapterMutation)(nil)

// chapterOption allows management of the mutation configuration using functional options.
type chapterOption func(*ChapterMutation)

// newChapterMutation creates new mutation for the Chapter entity.
func newChapterMutation(c config, op Op, opts ...chapterOption) *ChapterMutation {
	m := &ChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChapterID sets the ID field of the mutation.
func withChapterID(id string) chapterOption {
	return func(m *ChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *Chapter
		)
		m.oldValue = func(ctx context.Context) (*Chapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChapter sets the old Chapter of the mutation.
func withChapter(node *Chapter) chapterOption {
	return func(m *ChapterMutation) {
		m.oldValue = func(context.Context) (*Chapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Chapter entities.
func (m *ChapterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChapterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChapterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ChapterMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ChapterMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ChapterMutation) ResetTitle() {
	m.title = nil
}

// SetStartTime sets the "start_time" field.
func (m *ChapterMutation) SetStartTime(f float64) {
	m.start_time = &f
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ChapterMutation) StartTime() (r float64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldStartTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds f to the "start_time" field.
func (m *ChapterMutation) AddStartTime(f float64) {
	if m.addstart_time != nil {
		*m.addstart_time += f
	} else {
		m.addstart_time = &f
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *ChapterMutation) AddedStartTime() (r float64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ChapterMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ChapterMutation) SetEndTime(f float64) {
	m.end_time = &f
	m.addend_time = nil
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ChapterMutation) EndTime() (r float64, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldEndTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// AddEndTime adds f to the "end_time" field.
func (m *ChapterMutation) AddEndTime(f float64) {
	if m.addend_time != nil {
		*m.addend_time += f
	} else {
		m.addend_time = &f
	}
}

// AddedEndTime returns the value that was added to the "end_time" field in this mutation.
func (m *ChapterMutation) AddedEndTime() (r float64, exists bool) {
	v := m.addend_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ChapterMutation) ResetEndTime() {
	m.end_time = nil
	m.addend_time = nil
}

// SetVideoID sets the "video" edge to the Video entity by id.
func (m *ChapterMutation) SetVideoID(id string) {
	m.video = &id
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *ChapterMutation) ClearVideo() {
	m.clearedvideo = true
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *ChapterMutation) VideoCleared() bool {
	return m.clearedvideo
}

// VideoID returns the "video" edge ID in the mutation.
func (m *ChapterMutation) VideoID() (id string, exists bool) {
	if m.video != nil {
		return *m.video, true
	}
	return
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *ChapterMutation) VideoIDs() (ids []string) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *ChapterMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// Where appends a list predicates to the ChapterMutation builder.
func (m *ChapterMutation) Where(ps ...predicate.Chapter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChapterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChapterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chapter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChapterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChapterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chapter).
func (m *ChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChapterMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, chapter.FieldTitle)
	}
	if m.start_time != nil {
		fields = append(fields, chapter.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, chapter.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldTitle:
		return m.Title()
	case chapter.FieldStartTime:
		return m.StartTime()
	case chapter.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chapter.FieldTitle:
		return m.OldTitle(ctx)
	case chapter.FieldStartTime:
		return m.OldStartTime(ctx)
	case chapter.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown Chapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case chapter.FieldStartTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case chapter.FieldEndTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChapterMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time != nil {
		fields = append(fields, chapter.FieldStartTime)
	}
	if m.addend_time != nil {
		fields = append(fields, chapter.FieldEndTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChapterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldStartTime:
		return m.AddedStartTime()
	case chapter.FieldEndTime:
		return m.AddedEndTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldStartTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case chapter.FieldEndTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChapterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChapterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Chapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChapterMutation) ResetField(name string) error {
	switch name {
	case chapter.FieldTitle:
		m.ResetTitle()
		return nil
	case chapter.FieldStartTime:
		m.ResetStartTime()
		return nil
	case chapter.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.video != nil {
		edges = append(edges, chapter.EdgeVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chapter.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChapterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvideo {
		edges = append(edges, chapter.EdgeVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case chapter.EdgeVideo:
		return m.clearedvideo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChapterMutation) ClearEdge(name string) error {
	switch name {
	case chapter.EdgeVideo:
		m.ClearVideo()
		return nil
	}
	return fmt.Errorf("unknown Chapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChapterMutation) ResetEdge(name string) error {
	switch name {
	case chapter.EdgeVideo:
		m.ResetVideo()
		return nil
	}
	return fmt.Errorf("unknown Chapter edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	text               *string
	timestamp          *time.Time
	like_count         *int64
	addlike_count      *int64
	is_favorited       *bool
	author             *string
	author_id          *string
	author_thumbnail   *string
	author_is_uploader *bool
	parent             *string
	clearedFields      map[string]struct{}
	video              *string
	clearedvideo       bool
	done               bool
	oldValue           func(context.Context) (*Comment, error)
	predicates         []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id string) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *CommentMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *CommentMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *CommentMutation) ResetText() {
	m.text = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *CommentMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *CommentMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *CommentMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetLikeCount sets the "like_count" field.
func (m *CommentMutation) SetLikeCount(i int64) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *CommentMutation) LikeCount() (r int64, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikeCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *CommentMutation) AddLikeCount(i int64) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *CommentMutation) AddedLikeCount() (r int64, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *CommentMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetIsFavorited sets the "is_favorited" field.
func (m *CommentMutation) SetIsFavorited(b bool) {
	m.is_favorited = &b
}

// IsFavorited returns the value of the "is_favorited" field in the mutation.
func (m *CommentMutation) IsFavorited() (r bool, exists bool) {
	v := m.is_favorited
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFavorited returns the old "is_favorited" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsFavorited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFavorited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFavorited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFavorited: %w", err)
	}
	return oldValue.IsFavorited, nil
}

// ResetIsFavorited resets all changes to the "is_favorited" field.
func (m *CommentMutation) ResetIsFavorited() {
	m.is_favorited = nil
}

// SetAuthor sets the "author" field.
func (m *CommentMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *CommentMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
}

// SetAuthorID sets the "author_id" field.
func (m *CommentMutation) SetAuthorID(s string) {
	m.author_id = &s
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *CommentMutation) AuthorID() (r string, exists bool) {
	v := m.author_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *CommentMutation) ResetAuthorID() {
	m.author_id = nil
}

// SetAuthorThumbnail sets the "author_thumbnail" field.
func (m *CommentMutation) SetAuthorThumbnail(s string) {
	m.author_thumbnail = &s
}

// AuthorThumbnail returns the value of the "author_thumbnail" field in the mutation.
func (m *CommentMutation) AuthorThumbnail() (r string, exists bool) {
	v := m.author_thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorThumbnail returns the old "author_thumbnail" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthorThumbnail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorThumbnail: %w", err)
	}
	return oldValue.AuthorThumbnail, nil
}

// ResetAuthorThumbnail resets all changes to the "author_thumbnail" field.
func (m *CommentMutation) ResetAuthorThumbnail() {
	m.author_thumbnail = nil
}

// SetAuthorIsUploader sets the "author_is_uploader" field.
func (m *CommentMutation) SetAuthorIsUploader(b bool) {
	m.author_is_uploader = &b
}

// AuthorIsUploader returns the value of the "author_is_uploader" field in the mutation.
func (m *CommentMutation) AuthorIsUploader() (r bool, exists bool) {
	v := m.author_is_uploader
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorIsUploader returns the old "author_is_uploader" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthorIsUploader(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorIsUploader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorIsUploader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorIsUploader: %w", err)
	}
	return oldValue.AuthorIsUploader, nil
}

// ResetAuthorIsUploader resets all changes to the "author_is_uploader" field.
func (m *CommentMutation) ResetAuthorIsUploader() {
	m.author_is_uploader = nil
}

// SetParent sets the "parent" field.
func (m *CommentMutation) SetParent(s string) {
	m.parent = &s
}

// Parent returns the value of the "parent" field in the mutation.
func (m *CommentMutation) Parent() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParent returns the old "parent" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParent: %w", err)
	}
	return oldValue.Parent, nil
}

// ResetParent resets all changes to the "parent" field.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
}

// SetVideoID sets the "video" edge to the Video entity by id.
func (m *CommentMutation) SetVideoID(id string) {
	m.video = &id
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *CommentMutation) ClearVideo() {
	m.clearedvideo = true
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *CommentMutation) VideoCleared() bool {
	return m.clearedvideo
}

// VideoID returns the "video" edge ID in the mutation.
func (m *CommentMutation) VideoID() (id string, exists bool) {
	if m.video != nil {
		return *m.video, true
	}
	return
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) VideoIDs() (ids []string) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *CommentMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.text != nil {
		fields = append(fields, comment.FieldText)
	}
	if m.timestamp != nil {
		fields = append(fields, comment.FieldTimestamp)
	}
	if m.like_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.is_favorited != nil {
		fields = append(fields, comment.FieldIsFavorited)
	}
	if m.author != nil {
		fields = append(fields, comment.FieldAuthor)
	}
	if m.author_id != nil {
		fields = append(fields, comment.FieldAuthorID)
	}
	if m.author_thumbnail != nil {
		fields = append(fields, comment.FieldAuthorThumbnail)
	}
	if m.author_is_uploader != nil {
		fields = append(fields, comment.FieldAuthorIsUploader)
	}
	if m.parent != nil {
		fields = append(fields, comment.FieldParent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldText:
		return m.Text()
	case comment.FieldTimestamp:
		return m.Timestamp()
	case comment.FieldLikeCount:
		return m.LikeCount()
	case comment.FieldIsFavorited:
		return m.IsFavorited()
	case comment.FieldAuthor:
		return m.Author()
	case comment.FieldAuthorID:
		return m.AuthorID()
	case comment.FieldAuthorThumbnail:
		return m.AuthorThumbnail()
	case comment.FieldAuthorIsUploader:
		return m.AuthorIsUploader()
	case comment.FieldParent:
		return m.Parent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldText:
		return m.OldText(ctx)
	case comment.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case comment.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case comment.FieldIsFavorited:
		return m.OldIsFavorited(ctx)
	case comment.FieldAuthor:
		return m.OldAuthor(ctx)
	case comment.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case comment.FieldAuthorThumbnail:
		return m.OldAuthorThumbnail(ctx)
	case comment.FieldAuthorIsUploader:
		return m.OldAuthorIsUploader(ctx)
	case comment.FieldParent:
		return m.OldParent(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case comment.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case comment.FieldIsFavorited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFavorited(v)
		return nil
	case comment.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case comment.FieldAuthorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case comment.FieldAuthorThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorThumbnail(v)
		return nil
	case comment.FieldAuthorIsUploader:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorIsUploader(v)
		return nil
	case comment.FieldParent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParent(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addlike_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldLikeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldText:
		m.ResetText()
		return nil
	case comment.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case comment.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case comment.FieldIsFavorited:
		m.ResetIsFavorited()
		return nil
	case comment.FieldAuthor:
		m.ResetAuthor()
		return nil
	case comment.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case comment.FieldAuthorThumbnail:
		m.ResetAuthorThumbnail()
		return nil
	case comment.FieldAuthorIsUploader:
		m.ResetAuthorIsUploader()
		return nil
	case comment.FieldParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.video != nil {
		edges = append(edges, comment.EdgeVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvideo {
		edges = append(edges, comment.EdgeVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeVideo:
		return m.clearedvideo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeVideo:
		m.ClearVideo()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeVideo:
		m.ResetVideo()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// PlaybackMutation represents an operation that mutates the Playback nodes in the graph.
type PlaybackMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	video_id      *string
	timestamp     *int
	addtimestamp  *int
	status        *utils.PlaybackStatus
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Playback, error)
	predicates    []predicate.Playback
}

var _ ent.Mutation = (*PlaybackMutation)(nil)

// playbackOption allows management of the mutation configuration using functional options.
type playbackOption func(*PlaybackMutation)

// newPlaybackMutation creates new mutation for the Playback entity.
func newPlaybackMutation(c config, op Op, opts ...playbackOption) *PlaybackMutation {
	m := &PlaybackMutation{
		config:        c,
		op:            op,
		typ:           TypePlayback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaybackID sets the ID field of the mutation.
func withPlaybackID(id uuid.UUID) playbackOption {
	return func(m *PlaybackMutation) {
		var (
			err   error
			once  sync.Once
			value *Playback
		)
		m.oldValue = func(ctx context.Context) (*Playback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Playback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayback sets the old Playback of the mutation.
func withPlayback(node *Playback) playbackOption {
	return func(m *PlaybackMutation) {
		m.oldValue = func(context.Context) (*Playback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaybackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaybackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Playback entities.
func (m *PlaybackMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaybackMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaybackMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Playback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVideoID sets the "video_id" field.
func (m *PlaybackMutation) SetVideoID(s string) {
	m.video_id = &s
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *PlaybackMutation) VideoID() (r string, exists bool) {
	v := m.video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the Playback entity.
// If the Playback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybackMutation) OldVideoID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *PlaybackMutation) ResetVideoID() {
	m.video_id = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *PlaybackMutation) SetTimestamp(i int) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *PlaybackMutation) Timestamp() (r int, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Playback entity.
// If the Playback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybackMutation) OldTimestamp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *PlaybackMutation) AddTimestamp(i int) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *PlaybackMutation) AddedTimestamp() (r int, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *PlaybackMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// SetStatus sets the "status" field.
func (m *PlaybackMutation) SetStatus(us utils.PlaybackStatus) {
	m.status = &us
}

// Status returns the value of the "status" field in the mutation.
func (m *PlaybackMutation) Status() (r utils.PlaybackStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Playback entity.
// If the Playback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybackMutation) OldStatus(ctx context.Context) (v utils.PlaybackStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PlaybackMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[playback.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PlaybackMutation) StatusCleared() bool {
	_, ok := m.clearedFields[playback.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PlaybackMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, playback.FieldStatus)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlaybackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlaybackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Playback entity.
// If the Playback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlaybackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlaybackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlaybackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Playback entity.
// If the Playback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlaybackMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the PlaybackMutation builder.
func (m *PlaybackMutation) Where(ps ...predicate.Playback) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaybackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaybackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Playback, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaybackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaybackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Playback).
func (m *PlaybackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaybackMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.video_id != nil {
		fields = append(fields, playback.FieldVideoID)
	}
	if m.timestamp != nil {
		fields = append(fields, playback.FieldTimestamp)
	}
	if m.status != nil {
		fields = append(fields, playback.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, playback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, playback.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaybackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playback.FieldVideoID:
		return m.VideoID()
	case playback.FieldTimestamp:
		return m.Timestamp()
	case playback.FieldStatus:
		return m.Status()
	case playback.FieldCreatedAt:
		return m.CreatedAt()
	case playback.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaybackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playback.FieldVideoID:
		return m.OldVideoID(ctx)
	case playback.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case playback.FieldStatus:
		return m.OldStatus(ctx)
	case playback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case playback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Playback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaybackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playback.FieldVideoID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case playback.FieldTimestamp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case playback.FieldStatus:
		v, ok := value.(utils.PlaybackStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case playback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case playback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Playback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaybackMutation) AddedFields() []string {
	var fields []string
	if m.addtimestamp != nil {
		fields = append(fields, playback.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaybackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case playback.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaybackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case playback.FieldTimestamp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Playback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaybackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(playback.FieldStatus) {
		fields = append(fields, playback.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaybackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaybackMutation) ClearField(name string) error {
	switch name {
	case playback.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Playback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaybackMutation) ResetField(name string) error {
	switch name {
	case playback.FieldVideoID:
		m.ResetVideoID()
		return nil
	case playback.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case playback.FieldStatus:
		m.ResetStatus()
		return nil
	case playback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case playback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Playback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaybackMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaybackMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaybackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaybackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaybackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaybackMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaybackMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Playback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaybackMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Playback edge %s", name)
}

// VideoMutation represents an operation that mutates the Video nodes in the graph.
type VideoMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	title                    *string
	description              *string
	upload_date              *time.Time
	uploader                 *string
	duration                 *int64
	addduration              *int64
	view_count               *int64
	addview_count            *int64
	like_count               *int64
	addlike_count            *int64
	dislike_count            *int64
	adddislike_count         *int64
	format                   *string
	width                    *int64
	addwidth                 *int64
	height                   *int64
	addheight                *int64
	resolution               *string
	fps                      *float64
	addfps                   *float64
	audio_codec              *string
	video_codec              *string
	abr                      *float64
	addabr                   *float64
	vbr                      *float64
	addvbr                   *float64
	epoch                    *int64
	addepoch                 *int64
	comment_count            *int64
	addcomment_count         *int64
	tags                     *string
	categories               *string
	video_path               *string
	thumbnail_path           *string
	json_path                *string
	caption_path             *string
	_path                    *string
	thumbnails_path          *string
	thumbnails_width         *int
	addthumbnails_width      *int
	thumbnails_height        *int
	addthumbnails_height     *int
	thumbnails_interval      *float64
	addthumbnails_interval   *float64
	thumbnails_rows          *int
	addthumbnails_rows       *int
	eos_generated_thumbnails *bool
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	channel                  *string
	clearedchannel           bool
	chapters                 map[string]struct{}
	removedchapters          map[string]struct{}
	clearedchapters          bool
	comments                 map[string]struct{}
	removedcomments          map[string]struct{}
	clearedcomments          bool
	done                     bool
	oldValue                 func(context.Context) (*Video, error)
	predicates               []predicate.Video
}

var _ ent.Mutation = (*VideoMutation)(nil)

// videoOption allows management of the mutation configuration using functional options.
type videoOption func(*VideoMutation)

// newVideoMutation creates new mutation for the Video entity.
func newVideoMutation(c config, op Op, opts ...videoOption) *VideoMutation {
	m := &VideoMutation{
		config:        c,
		op:            op,
		typ:           TypeVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoID sets the ID field of the mutation.
func withVideoID(id string) videoOption {
	return func(m *VideoMutation) {
		var (
			err   error
			once  sync.Once
			value *Video
		)
		m.oldValue = func(ctx context.Context) (*Video, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Video.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideo sets the old Video of the mutation.
func withVideo(node *Video) videoOption {
	return func(m *VideoMutation) {
		m.oldValue = func(context.Context) (*Video, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Video entities.
func (m *VideoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Video.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *VideoMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VideoMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VideoMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VideoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VideoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VideoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[video.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VideoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[video.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VideoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, video.FieldDescription)
}

// SetUploadDate sets the "upload_date" field.
func (m *VideoMutation) SetUploadDate(t time.Time) {
	m.upload_date = &t
}

// UploadDate returns the value of the "upload_date" field in the mutation.
func (m *VideoMutation) UploadDate() (r time.Time, exists bool) {
	v := m.upload_date
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadDate returns the old "upload_date" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUploadDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadDate: %w", err)
	}
	return oldValue.UploadDate, nil
}

// ResetUploadDate resets all changes to the "upload_date" field.
func (m *VideoMutation) ResetUploadDate() {
	m.upload_date = nil
}

// SetUploader sets the "uploader" field.
func (m *VideoMutation) SetUploader(s string) {
	m.uploader = &s
}

// Uploader returns the value of the "uploader" field in the mutation.
func (m *VideoMutation) Uploader() (r string, exists bool) {
	v := m.uploader
	if v == nil {
		return
	}
	return *v, true
}

// OldUploader returns the old "uploader" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUploader(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploader: %w", err)
	}
	return oldValue.Uploader, nil
}

// ResetUploader resets all changes to the "uploader" field.
func (m *VideoMutation) ResetUploader() {
	m.uploader = nil
}

// SetDuration sets the "duration" field.
func (m *VideoMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VideoMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *VideoMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *VideoMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *VideoMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetViewCount sets the "view_count" field.
func (m *VideoMutation) SetViewCount(i int64) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *VideoMutation) ViewCount() (r int64, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldViewCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *VideoMutation) AddViewCount(i int64) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *VideoMutation) AddedViewCount() (r int64, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *VideoMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *VideoMutation) SetLikeCount(i int64) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *VideoMutation) LikeCount() (r int64, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldLikeCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *VideoMutation) AddLikeCount(i int64) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *VideoMutation) AddedLikeCount() (r int64, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *VideoMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *VideoMutation) SetDislikeCount(i int64) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *VideoMutation) DislikeCount() (r int64, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDislikeCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *VideoMutation) AddDislikeCount(i int64) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *VideoMutation) AddedDislikeCount() (r int64, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearDislikeCount clears the value of the "dislike_count" field.
func (m *VideoMutation) ClearDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
	m.clearedFields[video.FieldDislikeCount] = struct{}{}
}

// DislikeCountCleared returns if the "dislike_count" field was cleared in this mutation.
func (m *VideoMutation) DislikeCountCleared() bool {
	_, ok := m.clearedFields[video.FieldDislikeCount]
	return ok
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *VideoMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
	delete(m.clearedFields, video.FieldDislikeCount)
}

// SetFormat sets the "format" field.
func (m *VideoMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *VideoMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ClearFormat clears the value of the "format" field.
func (m *VideoMutation) ClearFormat() {
	m.format = nil
	m.clearedFields[video.FieldFormat] = struct{}{}
}

// FormatCleared returns if the "format" field was cleared in this mutation.
func (m *VideoMutation) FormatCleared() bool {
	_, ok := m.clearedFields[video.FieldFormat]
	return ok
}

// ResetFormat resets all changes to the "format" field.
func (m *VideoMutation) ResetFormat() {
	m.format = nil
	delete(m.clearedFields, video.FieldFormat)
}

// SetWidth sets the "width" field.
func (m *VideoMutation) SetWidth(i int64) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *VideoMutation) Width() (r int64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldWidth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *VideoMutation) AddWidth(i int64) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *VideoMutation) AddedWidth() (r int64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *VideoMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[video.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *VideoMutation) WidthCleared() bool {
	_, ok := m.clearedFields[video.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *VideoMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, video.FieldWidth)
}

// SetHeight sets the "height" field.
func (m *VideoMutation) SetHeight(i int64) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *VideoMutation) Height() (r int64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *VideoMutation) AddHeight(i int64) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *VideoMutation) AddedHeight() (r int64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *VideoMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[video.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *VideoMutation) HeightCleared() bool {
	_, ok := m.clearedFields[video.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *VideoMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, video.FieldHeight)
}

// SetResolution sets the "resolution" field.
func (m *VideoMutation) SetResolution(s string) {
	m.resolution = &s
}

// Resolution returns the value of the "resolution" field in the mutation.
func (m *VideoMutation) Resolution() (r string, exists bool) {
	v := m.resolution
	if v == nil {
		return
	}
	return *v, true
}

// OldResolution returns the old "resolution" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldResolution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolution: %w", err)
	}
	return oldValue.Resolution, nil
}

// ClearResolution clears the value of the "resolution" field.
func (m *VideoMutation) ClearResolution() {
	m.resolution = nil
	m.clearedFields[video.FieldResolution] = struct{}{}
}

// ResolutionCleared returns if the "resolution" field was cleared in this mutation.
func (m *VideoMutation) ResolutionCleared() bool {
	_, ok := m.clearedFields[video.FieldResolution]
	return ok
}

// ResetResolution resets all changes to the "resolution" field.
func (m *VideoMutation) ResetResolution() {
	m.resolution = nil
	delete(m.clearedFields, video.FieldResolution)
}

// SetFps sets the "fps" field.
func (m *VideoMutation) SetFps(f float64) {
	m.fps = &f
	m.addfps = nil
}

// Fps returns the value of the "fps" field in the mutation.
func (m *VideoMutation) Fps() (r float64, exists bool) {
	v := m.fps
	if v == nil {
		return
	}
	return *v, true
}

// OldFps returns the old "fps" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldFps(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFps: %w", err)
	}
	return oldValue.Fps, nil
}

// AddFps adds f to the "fps" field.
func (m *VideoMutation) AddFps(f float64) {
	if m.addfps != nil {
		*m.addfps += f
	} else {
		m.addfps = &f
	}
}

// AddedFps returns the value that was added to the "fps" field in this mutation.
func (m *VideoMutation) AddedFps() (r float64, exists bool) {
	v := m.addfps
	if v == nil {
		return
	}
	return *v, true
}

// ClearFps clears the value of the "fps" field.
func (m *VideoMutation) ClearFps() {
	m.fps = nil
	m.addfps = nil
	m.clearedFields[video.FieldFps] = struct{}{}
}

// FpsCleared returns if the "fps" field was cleared in this mutation.
func (m *VideoMutation) FpsCleared() bool {
	_, ok := m.clearedFields[video.FieldFps]
	return ok
}

// ResetFps resets all changes to the "fps" field.
func (m *VideoMutation) ResetFps() {
	m.fps = nil
	m.addfps = nil
	delete(m.clearedFields, video.FieldFps)
}

// SetAudioCodec sets the "audio_codec" field.
func (m *VideoMutation) SetAudioCodec(s string) {
	m.audio_codec = &s
}

// AudioCodec returns the value of the "audio_codec" field in the mutation.
func (m *VideoMutation) AudioCodec() (r string, exists bool) {
	v := m.audio_codec
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioCodec returns the old "audio_codec" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldAudioCodec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioCodec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioCodec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioCodec: %w", err)
	}
	return oldValue.AudioCodec, nil
}

// ClearAudioCodec clears the value of the "audio_codec" field.
func (m *VideoMutation) ClearAudioCodec() {
	m.audio_codec = nil
	m.clearedFields[video.FieldAudioCodec] = struct{}{}
}

// AudioCodecCleared returns if the "audio_codec" field was cleared in this mutation.
func (m *VideoMutation) AudioCodecCleared() bool {
	_, ok := m.clearedFields[video.FieldAudioCodec]
	return ok
}

// ResetAudioCodec resets all changes to the "audio_codec" field.
func (m *VideoMutation) ResetAudioCodec() {
	m.audio_codec = nil
	delete(m.clearedFields, video.FieldAudioCodec)
}

// SetVideoCodec sets the "video_codec" field.
func (m *VideoMutation) SetVideoCodec(s string) {
	m.video_codec = &s
}

// VideoCodec returns the value of the "video_codec" field in the mutation.
func (m *VideoMutation) VideoCodec() (r string, exists bool) {
	v := m.video_codec
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoCodec returns the old "video_codec" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldVideoCodec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoCodec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoCodec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoCodec: %w", err)
	}
	return oldValue.VideoCodec, nil
}

// ClearVideoCodec clears the value of the "video_codec" field.
func (m *VideoMutation) ClearVideoCodec() {
	m.video_codec = nil
	m.clearedFields[video.FieldVideoCodec] = struct{}{}
}

// VideoCodecCleared returns if the "video_codec" field was cleared in this mutation.
func (m *VideoMutation) VideoCodecCleared() bool {
	_, ok := m.clearedFields[video.FieldVideoCodec]
	return ok
}

// ResetVideoCodec resets all changes to the "video_codec" field.
func (m *VideoMutation) ResetVideoCodec() {
	m.video_codec = nil
	delete(m.clearedFields, video.FieldVideoCodec)
}

// SetAbr sets the "abr" field.
func (m *VideoMutation) SetAbr(f float64) {
	m.abr = &f
	m.addabr = nil
}

// Abr returns the value of the "abr" field in the mutation.
func (m *VideoMutation) Abr() (r float64, exists bool) {
	v := m.abr
	if v == nil {
		return
	}
	return *v, true
}

// OldAbr returns the old "abr" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldAbr(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbr: %w", err)
	}
	return oldValue.Abr, nil
}

// AddAbr adds f to the "abr" field.
func (m *VideoMutation) AddAbr(f float64) {
	if m.addabr != nil {
		*m.addabr += f
	} else {
		m.addabr = &f
	}
}

// AddedAbr returns the value that was added to the "abr" field in this mutation.
func (m *VideoMutation) AddedAbr() (r float64, exists bool) {
	v := m.addabr
	if v == nil {
		return
	}
	return *v, true
}

// ClearAbr clears the value of the "abr" field.
func (m *VideoMutation) ClearAbr() {
	m.abr = nil
	m.addabr = nil
	m.clearedFields[video.FieldAbr] = struct{}{}
}

// AbrCleared returns if the "abr" field was cleared in this mutation.
func (m *VideoMutation) AbrCleared() bool {
	_, ok := m.clearedFields[video.FieldAbr]
	return ok
}

// ResetAbr resets all changes to the "abr" field.
func (m *VideoMutation) ResetAbr() {
	m.abr = nil
	m.addabr = nil
	delete(m.clearedFields, video.FieldAbr)
}

// SetVbr sets the "vbr" field.
func (m *VideoMutation) SetVbr(f float64) {
	m.vbr = &f
	m.addvbr = nil
}

// Vbr returns the value of the "vbr" field in the mutation.
func (m *VideoMutation) Vbr() (r float64, exists bool) {
	v := m.vbr
	if v == nil {
		return
	}
	return *v, true
}

// OldVbr returns the old "vbr" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldVbr(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVbr: %w", err)
	}
	return oldValue.Vbr, nil
}

// AddVbr adds f to the "vbr" field.
func (m *VideoMutation) AddVbr(f float64) {
	if m.addvbr != nil {
		*m.addvbr += f
	} else {
		m.addvbr = &f
	}
}

// AddedVbr returns the value that was added to the "vbr" field in this mutation.
func (m *VideoMutation) AddedVbr() (r float64, exists bool) {
	v := m.addvbr
	if v == nil {
		return
	}
	return *v, true
}

// ClearVbr clears the value of the "vbr" field.
func (m *VideoMutation) ClearVbr() {
	m.vbr = nil
	m.addvbr = nil
	m.clearedFields[video.FieldVbr] = struct{}{}
}

// VbrCleared returns if the "vbr" field was cleared in this mutation.
func (m *VideoMutation) VbrCleared() bool {
	_, ok := m.clearedFields[video.FieldVbr]
	return ok
}

// ResetVbr resets all changes to the "vbr" field.
func (m *VideoMutation) ResetVbr() {
	m.vbr = nil
	m.addvbr = nil
	delete(m.clearedFields, video.FieldVbr)
}

// SetEpoch sets the "epoch" field.
func (m *VideoMutation) SetEpoch(i int64) {
	m.epoch = &i
	m.addepoch = nil
}

// Epoch returns the value of the "epoch" field in the mutation.
func (m *VideoMutation) Epoch() (r int64, exists bool) {
	v := m.epoch
	if v == nil {
		return
	}
	return *v, true
}

// OldEpoch returns the old "epoch" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldEpoch(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpoch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpoch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpoch: %w", err)
	}
	return oldValue.Epoch, nil
}

// AddEpoch adds i to the "epoch" field.
func (m *VideoMutation) AddEpoch(i int64) {
	if m.addepoch != nil {
		*m.addepoch += i
	} else {
		m.addepoch = &i
	}
}

// AddedEpoch returns the value that was added to the "epoch" field in this mutation.
func (m *VideoMutation) AddedEpoch() (r int64, exists bool) {
	v := m.addepoch
	if v == nil {
		return
	}
	return *v, true
}

// ClearEpoch clears the value of the "epoch" field.
func (m *VideoMutation) ClearEpoch() {
	m.epoch = nil
	m.addepoch = nil
	m.clearedFields[video.FieldEpoch] = struct{}{}
}

// EpochCleared returns if the "epoch" field was cleared in this mutation.
func (m *VideoMutation) EpochCleared() bool {
	_, ok := m.clearedFields[video.FieldEpoch]
	return ok
}

// ResetEpoch resets all changes to the "epoch" field.
func (m *VideoMutation) ResetEpoch() {
	m.epoch = nil
	m.addepoch = nil
	delete(m.clearedFields, video.FieldEpoch)
}

// SetCommentCount sets the "comment_count" field.
func (m *VideoMutation) SetCommentCount(i int64) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *VideoMutation) CommentCount() (r int64, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCommentCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *VideoMutation) AddCommentCount(i int64) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *VideoMutation) AddedCommentCount() (r int64, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommentCount clears the value of the "comment_count" field.
func (m *VideoMutation) ClearCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	m.clearedFields[video.FieldCommentCount] = struct{}{}
}

// CommentCountCleared returns if the "comment_count" field was cleared in this mutation.
func (m *VideoMutation) CommentCountCleared() bool {
	_, ok := m.clearedFields[video.FieldCommentCount]
	return ok
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *VideoMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	delete(m.clearedFields, video.FieldCommentCount)
}

// SetTags sets the "tags" field.
func (m *VideoMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *VideoMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *VideoMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[video.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *VideoMutation) TagsCleared() bool {
	_, ok := m.clearedFields[video.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *VideoMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, video.FieldTags)
}

// SetCategories sets the "categories" field.
func (m *VideoMutation) SetCategories(s string) {
	m.categories = &s
}

// Categories returns the value of the "categories" field in the mutation.
func (m *VideoMutation) Categories() (r string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCategories(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// ClearCategories clears the value of the "categories" field.
func (m *VideoMutation) ClearCategories() {
	m.categories = nil
	m.clearedFields[video.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *VideoMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[video.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *VideoMutation) ResetCategories() {
	m.categories = nil
	delete(m.clearedFields, video.FieldCategories)
}

// SetVideoPath sets the "video_path" field.
func (m *VideoMutation) SetVideoPath(s string) {
	m.video_path = &s
}

// VideoPath returns the value of the "video_path" field in the mutation.
func (m *VideoMutation) VideoPath() (r string, exists bool) {
	v := m.video_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoPath returns the old "video_path" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldVideoPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoPath: %w", err)
	}
	return oldValue.VideoPath, nil
}

// ResetVideoPath resets all changes to the "video_path" field.
func (m *VideoMutation) ResetVideoPath() {
	m.video_path = nil
}

// SetThumbnailPath sets the "thumbnail_path" field.
func (m *VideoMutation) SetThumbnailPath(s string) {
	m.thumbnail_path = &s
}

// ThumbnailPath returns the value of the "thumbnail_path" field in the mutation.
func (m *VideoMutation) ThumbnailPath() (r string, exists bool) {
	v := m.thumbnail_path
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailPath returns the old "thumbnail_path" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldThumbnailPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailPath: %w", err)
	}
	return oldValue.ThumbnailPath, nil
}

// ResetThumbnailPath resets all changes to the "thumbnail_path" field.
func (m *VideoMutation) ResetThumbnailPath() {
	m.thumbnail_path = nil
}

// SetJSONPath sets the "json_path" field.
func (m *VideoMutation) SetJSONPath(s string) {
	m.json_path = &s
}

// JSONPath returns the value of the "json_path" field in the mutation.
func (m *VideoMutation) JSONPath() (r string, exists bool) {
	v := m.json_path
	if v == nil {
		return
	}
	return *v, true
}

// OldJSONPath returns the old "json_path" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldJSONPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJSONPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJSONPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJSONPath: %w", err)
	}
	return oldValue.JSONPath, nil
}

// ResetJSONPath resets all changes to the "json_path" field.
func (m *VideoMutation) ResetJSONPath() {
	m.json_path = nil
}

// SetCaptionPath sets the "caption_path" field.
func (m *VideoMutation) SetCaptionPath(s string) {
	m.caption_path = &s
}

// CaptionPath returns the value of the "caption_path" field in the mutation.
func (m *VideoMutation) CaptionPath() (r string, exists bool) {
	v := m.caption_path
	if v == nil {
		return
	}
	return *v, true
}

// OldCaptionPath returns the old "caption_path" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCaptionPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaptionPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaptionPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaptionPath: %w", err)
	}
	return oldValue.CaptionPath, nil
}

// ClearCaptionPath clears the value of the "caption_path" field.
func (m *VideoMutation) ClearCaptionPath() {
	m.caption_path = nil
	m.clearedFields[video.FieldCaptionPath] = struct{}{}
}

// CaptionPathCleared returns if the "caption_path" field was cleared in this mutation.
func (m *VideoMutation) CaptionPathCleared() bool {
	_, ok := m.clearedFields[video.FieldCaptionPath]
	return ok
}

// ResetCaptionPath resets all changes to the "caption_path" field.
func (m *VideoMutation) ResetCaptionPath() {
	m.caption_path = nil
	delete(m.clearedFields, video.FieldCaptionPath)
}

// SetPath sets the "path" field.
func (m *VideoMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *VideoMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *VideoMutation) ResetPath() {
	m._path = nil
}

// SetThumbnailsPath sets the "thumbnails_path" field.
func (m *VideoMutation) SetThumbnailsPath(s string) {
	m.thumbnails_path = &s
}

// ThumbnailsPath returns the value of the "thumbnails_path" field in the mutation.
func (m *VideoMutation) ThumbnailsPath() (r string, exists bool) {
	v := m.thumbnails_path
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailsPath returns the old "thumbnails_path" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldThumbnailsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailsPath: %w", err)
	}
	return oldValue.ThumbnailsPath, nil
}

// ClearThumbnailsPath clears the value of the "thumbnails_path" field.
func (m *VideoMutation) ClearThumbnailsPath() {
	m.thumbnails_path = nil
	m.clearedFields[video.FieldThumbnailsPath] = struct{}{}
}

// ThumbnailsPathCleared returns if the "thumbnails_path" field was cleared in this mutation.
func (m *VideoMutation) ThumbnailsPathCleared() bool {
	_, ok := m.clearedFields[video.FieldThumbnailsPath]
	return ok
}

// ResetThumbnailsPath resets all changes to the "thumbnails_path" field.
func (m *VideoMutation) ResetThumbnailsPath() {
	m.thumbnails_path = nil
	delete(m.clearedFields, video.FieldThumbnailsPath)
}

// SetThumbnailsWidth sets the "thumbnails_width" field.
func (m *VideoMutation) SetThumbnailsWidth(i int) {
	m.thumbnails_width = &i
	m.addthumbnails_width = nil
}

// ThumbnailsWidth returns the value of the "thumbnails_width" field in the mutation.
func (m *VideoMutation) ThumbnailsWidth() (r int, exists bool) {
	v := m.thumbnails_width
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailsWidth returns the old "thumbnails_width" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldThumbnailsWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailsWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailsWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailsWidth: %w", err)
	}
	return oldValue.ThumbnailsWidth, nil
}

// AddThumbnailsWidth adds i to the "thumbnails_width" field.
func (m *VideoMutation) AddThumbnailsWidth(i int) {
	if m.addthumbnails_width != nil {
		*m.addthumbnails_width += i
	} else {
		m.addthumbnails_width = &i
	}
}

// AddedThumbnailsWidth returns the value that was added to the "thumbnails_width" field in this mutation.
func (m *VideoMutation) AddedThumbnailsWidth() (r int, exists bool) {
	v := m.addthumbnails_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearThumbnailsWidth clears the value of the "thumbnails_width" field.
func (m *VideoMutation) ClearThumbnailsWidth() {
	m.thumbnails_width = nil
	m.addthumbnails_width = nil
	m.clearedFields[video.FieldThumbnailsWidth] = struct{}{}
}

// ThumbnailsWidthCleared returns if the "thumbnails_width" field was cleared in this mutation.
func (m *VideoMutation) ThumbnailsWidthCleared() bool {
	_, ok := m.clearedFields[video.FieldThumbnailsWidth]
	return ok
}

// ResetThumbnailsWidth resets all changes to the "thumbnails_width" field.
func (m *VideoMutation) ResetThumbnailsWidth() {
	m.thumbnails_width = nil
	m.addthumbnails_width = nil
	delete(m.clearedFields, video.FieldThumbnailsWidth)
}

// SetThumbnailsHeight sets the "thumbnails_height" field.
func (m *VideoMutation) SetThumbnailsHeight(i int) {
	m.thumbnails_height = &i
	m.addthumbnails_height = nil
}

// ThumbnailsHeight returns the value of the "thumbnails_height" field in the mutation.
func (m *VideoMutation) ThumbnailsHeight() (r int, exists bool) {
	v := m.thumbnails_height
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailsHeight returns the old "thumbnails_height" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldThumbnailsHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailsHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailsHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailsHeight: %w", err)
	}
	return oldValue.ThumbnailsHeight, nil
}

// AddThumbnailsHeight adds i to the "thumbnails_height" field.
func (m *VideoMutation) AddThumbnailsHeight(i int) {
	if m.addthumbnails_height != nil {
		*m.addthumbnails_height += i
	} else {
		m.addthumbnails_height = &i
	}
}

// AddedThumbnailsHeight returns the value that was added to the "thumbnails_height" field in this mutation.
func (m *VideoMutation) AddedThumbnailsHeight() (r int, exists bool) {
	v := m.addthumbnails_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearThumbnailsHeight clears the value of the "thumbnails_height" field.
func (m *VideoMutation) ClearThumbnailsHeight() {
	m.thumbnails_height = nil
	m.addthumbnails_height = nil
	m.clearedFields[video.FieldThumbnailsHeight] = struct{}{}
}

// ThumbnailsHeightCleared returns if the "thumbnails_height" field was cleared in this mutation.
func (m *VideoMutation) ThumbnailsHeightCleared() bool {
	_, ok := m.clearedFields[video.FieldThumbnailsHeight]
	return ok
}

// ResetThumbnailsHeight resets all changes to the "thumbnails_height" field.
func (m *VideoMutation) ResetThumbnailsHeight() {
	m.thumbnails_height = nil
	m.addthumbnails_height = nil
	delete(m.clearedFields, video.FieldThumbnailsHeight)
}

// SetThumbnailsInterval sets the "thumbnails_interval" field.
func (m *VideoMutation) SetThumbnailsInterval(f float64) {
	m.thumbnails_interval = &f
	m.addthumbnails_interval = nil
}

// ThumbnailsInterval returns the value of the "thumbnails_interval" field in the mutation.
func (m *VideoMutation) ThumbnailsInterval() (r float64, exists bool) {
	v := m.thumbnails_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailsInterval returns the old "thumbnails_interval" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldThumbnailsInterval(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailsInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailsInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailsInterval: %w", err)
	}
	return oldValue.ThumbnailsInterval, nil
}

// AddThumbnailsInterval adds f to the "thumbnails_interval" field.
func (m *VideoMutation) AddThumbnailsInterval(f float64) {
	if m.addthumbnails_interval != nil {
		*m.addthumbnails_interval += f
	} else {
		m.addthumbnails_interval = &f
	}
}

// AddedThumbnailsInterval returns the value that was added to the "thumbnails_interval" field in this mutation.
func (m *VideoMutation) AddedThumbnailsInterval() (r float64, exists bool) {
	v := m.addthumbnails_interval
	if v == nil {
		return
	}
	return *v, true
}

// ClearThumbnailsInterval clears the value of the "thumbnails_interval" field.
func (m *VideoMutation) ClearThumbnailsInterval() {
	m.thumbnails_interval = nil
	m.addthumbnails_interval = nil
	m.clearedFields[video.FieldThumbnailsInterval] = struct{}{}
}

// ThumbnailsIntervalCleared returns if the "thumbnails_interval" field was cleared in this mutation.
func (m *VideoMutation) ThumbnailsIntervalCleared() bool {
	_, ok := m.clearedFields[video.FieldThumbnailsInterval]
	return ok
}

// ResetThumbnailsInterval resets all changes to the "thumbnails_interval" field.
func (m *VideoMutation) ResetThumbnailsInterval() {
	m.thumbnails_interval = nil
	m.addthumbnails_interval = nil
	delete(m.clearedFields, video.FieldThumbnailsInterval)
}

// SetThumbnailsRows sets the "thumbnails_rows" field.
func (m *VideoMutation) SetThumbnailsRows(i int) {
	m.thumbnails_rows = &i
	m.addthumbnails_rows = nil
}

// ThumbnailsRows returns the value of the "thumbnails_rows" field in the mutation.
func (m *VideoMutation) ThumbnailsRows() (r int, exists bool) {
	v := m.thumbnails_rows
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailsRows returns the old "thumbnails_rows" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldThumbnailsRows(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailsRows is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailsRows requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailsRows: %w", err)
	}
	return oldValue.ThumbnailsRows, nil
}

// AddThumbnailsRows adds i to the "thumbnails_rows" field.
func (m *VideoMutation) AddThumbnailsRows(i int) {
	if m.addthumbnails_rows != nil {
		*m.addthumbnails_rows += i
	} else {
		m.addthumbnails_rows = &i
	}
}

// AddedThumbnailsRows returns the value that was added to the "thumbnails_rows" field in this mutation.
func (m *VideoMutation) AddedThumbnailsRows() (r int, exists bool) {
	v := m.addthumbnails_rows
	if v == nil {
		return
	}
	return *v, true
}

// ClearThumbnailsRows clears the value of the "thumbnails_rows" field.
func (m *VideoMutation) ClearThumbnailsRows() {
	m.thumbnails_rows = nil
	m.addthumbnails_rows = nil
	m.clearedFields[video.FieldThumbnailsRows] = struct{}{}
}

// ThumbnailsRowsCleared returns if the "thumbnails_rows" field was cleared in this mutation.
func (m *VideoMutation) ThumbnailsRowsCleared() bool {
	_, ok := m.clearedFields[video.FieldThumbnailsRows]
	return ok
}

// ResetThumbnailsRows resets all changes to the "thumbnails_rows" field.
func (m *VideoMutation) ResetThumbnailsRows() {
	m.thumbnails_rows = nil
	m.addthumbnails_rows = nil
	delete(m.clearedFields, video.FieldThumbnailsRows)
}

// SetEosGeneratedThumbnails sets the "eos_generated_thumbnails" field.
func (m *VideoMutation) SetEosGeneratedThumbnails(b bool) {
	m.eos_generated_thumbnails = &b
}

// EosGeneratedThumbnails returns the value of the "eos_generated_thumbnails" field in the mutation.
func (m *VideoMutation) EosGeneratedThumbnails() (r bool, exists bool) {
	v := m.eos_generated_thumbnails
	if v == nil {
		return
	}
	return *v, true
}

// OldEosGeneratedThumbnails returns the old "eos_generated_thumbnails" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldEosGeneratedThumbnails(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEosGeneratedThumbnails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEosGeneratedThumbnails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEosGeneratedThumbnails: %w", err)
	}
	return oldValue.EosGeneratedThumbnails, nil
}

// ClearEosGeneratedThumbnails clears the value of the "eos_generated_thumbnails" field.
func (m *VideoMutation) ClearEosGeneratedThumbnails() {
	m.eos_generated_thumbnails = nil
	m.clearedFields[video.FieldEosGeneratedThumbnails] = struct{}{}
}

// EosGeneratedThumbnailsCleared returns if the "eos_generated_thumbnails" field was cleared in this mutation.
func (m *VideoMutation) EosGeneratedThumbnailsCleared() bool {
	_, ok := m.clearedFields[video.FieldEosGeneratedThumbnails]
	return ok
}

// ResetEosGeneratedThumbnails resets all changes to the "eos_generated_thumbnails" field.
func (m *VideoMutation) ResetEosGeneratedThumbnails() {
	m.eos_generated_thumbnails = nil
	delete(m.clearedFields, video.FieldEosGeneratedThumbnails)
}

// SetCreatedAt sets the "created_at" field.
func (m *VideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VideoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VideoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *VideoMutation) SetChannelID(id string) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *VideoMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *VideoMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *VideoMutation) ChannelID() (id string, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) ChannelIDs() (ids []string) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *VideoMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// AddChapterIDs adds the "chapters" edge to the Chapter entity by ids.
func (m *VideoMutation) AddChapterIDs(ids ...string) {
	if m.chapters == nil {
		m.chapters = make(map[string]struct{})
	}
	for i := range ids {
		m.chapters[ids[i]] = struct{}{}
	}
}

// ClearChapters clears the "chapters" edge to the Chapter entity.
func (m *VideoMutation) ClearChapters() {
	m.clearedchapters = true
}

// ChaptersCleared reports if the "chapters" edge to the Chapter entity was cleared.
func (m *VideoMutation) ChaptersCleared() bool {
	return m.clearedchapters
}

// RemoveChapterIDs removes the "chapters" edge to the Chapter entity by IDs.
func (m *VideoMutation) RemoveChapterIDs(ids ...string) {
	if m.removedchapters == nil {
		m.removedchapters = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.chapters, ids[i])
		m.removedchapters[ids[i]] = struct{}{}
	}
}

// RemovedChapters returns the removed IDs of the "chapters" edge to the Chapter entity.
func (m *VideoMutation) RemovedChaptersIDs() (ids []string) {
	for id := range m.removedchapters {
		ids = append(ids, id)
	}
	return
}

// ChaptersIDs returns the "chapters" edge IDs in the mutation.
func (m *VideoMutation) ChaptersIDs() (ids []string) {
	for id := range m.chapters {
		ids = append(ids, id)
	}
	return
}

// ResetChapters resets all changes to the "chapters" edge.
func (m *VideoMutation) ResetChapters() {
	m.chapters = nil
	m.clearedchapters = false
	m.removedchapters = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *VideoMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *VideoMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *VideoMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *VideoMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *VideoMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *VideoMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *VideoMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the VideoMutation builder.
func (m *VideoMutation) Where(ps ...predicate.Video) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Video, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Video).
func (m *VideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.title != nil {
		fields = append(fields, video.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, video.FieldDescription)
	}
	if m.upload_date != nil {
		fields = append(fields, video.FieldUploadDate)
	}
	if m.uploader != nil {
		fields = append(fields, video.FieldUploader)
	}
	if m.duration != nil {
		fields = append(fields, video.FieldDuration)
	}
	if m.view_count != nil {
		fields = append(fields, video.FieldViewCount)
	}
	if m.like_count != nil {
		fields = append(fields, video.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, video.FieldDislikeCount)
	}
	if m.format != nil {
		fields = append(fields, video.FieldFormat)
	}
	if m.width != nil {
		fields = append(fields, video.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, video.FieldHeight)
	}
	if m.resolution != nil {
		fields = append(fields, video.FieldResolution)
	}
	if m.fps != nil {
		fields = append(fields, video.FieldFps)
	}
	if m.audio_codec != nil {
		fields = append(fields, video.FieldAudioCodec)
	}
	if m.video_codec != nil {
		fields = append(fields, video.FieldVideoCodec)
	}
	if m.abr != nil {
		fields = append(fields, video.FieldAbr)
	}
	if m.vbr != nil {
		fields = append(fields, video.FieldVbr)
	}
	if m.epoch != nil {
		fields = append(fields, video.FieldEpoch)
	}
	if m.comment_count != nil {
		fields = append(fields, video.FieldCommentCount)
	}
	if m.tags != nil {
		fields = append(fields, video.FieldTags)
	}
	if m.categories != nil {
		fields = append(fields, video.FieldCategories)
	}
	if m.video_path != nil {
		fields = append(fields, video.FieldVideoPath)
	}
	if m.thumbnail_path != nil {
		fields = append(fields, video.FieldThumbnailPath)
	}
	if m.json_path != nil {
		fields = append(fields, video.FieldJSONPath)
	}
	if m.caption_path != nil {
		fields = append(fields, video.FieldCaptionPath)
	}
	if m._path != nil {
		fields = append(fields, video.FieldPath)
	}
	if m.thumbnails_path != nil {
		fields = append(fields, video.FieldThumbnailsPath)
	}
	if m.thumbnails_width != nil {
		fields = append(fields, video.FieldThumbnailsWidth)
	}
	if m.thumbnails_height != nil {
		fields = append(fields, video.FieldThumbnailsHeight)
	}
	if m.thumbnails_interval != nil {
		fields = append(fields, video.FieldThumbnailsInterval)
	}
	if m.thumbnails_rows != nil {
		fields = append(fields, video.FieldThumbnailsRows)
	}
	if m.eos_generated_thumbnails != nil {
		fields = append(fields, video.FieldEosGeneratedThumbnails)
	}
	if m.created_at != nil {
		fields = append(fields, video.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, video.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case video.FieldTitle:
		return m.Title()
	case video.FieldDescription:
		return m.Description()
	case video.FieldUploadDate:
		return m.UploadDate()
	case video.FieldUploader:
		return m.Uploader()
	case video.FieldDuration:
		return m.Duration()
	case video.FieldViewCount:
		return m.ViewCount()
	case video.FieldLikeCount:
		return m.LikeCount()
	case video.FieldDislikeCount:
		return m.DislikeCount()
	case video.FieldFormat:
		return m.Format()
	case video.FieldWidth:
		return m.Width()
	case video.FieldHeight:
		return m.Height()
	case video.FieldResolution:
		return m.Resolution()
	case video.FieldFps:
		return m.Fps()
	case video.FieldAudioCodec:
		return m.AudioCodec()
	case video.FieldVideoCodec:
		return m.VideoCodec()
	case video.FieldAbr:
		return m.Abr()
	case video.FieldVbr:
		return m.Vbr()
	case video.FieldEpoch:
		return m.Epoch()
	case video.FieldCommentCount:
		return m.CommentCount()
	case video.FieldTags:
		return m.Tags()
	case video.FieldCategories:
		return m.Categories()
	case video.FieldVideoPath:
		return m.VideoPath()
	case video.FieldThumbnailPath:
		return m.ThumbnailPath()
	case video.FieldJSONPath:
		return m.JSONPath()
	case video.FieldCaptionPath:
		return m.CaptionPath()
	case video.FieldPath:
		return m.Path()
	case video.FieldThumbnailsPath:
		return m.ThumbnailsPath()
	case video.FieldThumbnailsWidth:
		return m.ThumbnailsWidth()
	case video.FieldThumbnailsHeight:
		return m.ThumbnailsHeight()
	case video.FieldThumbnailsInterval:
		return m.ThumbnailsInterval()
	case video.FieldThumbnailsRows:
		return m.ThumbnailsRows()
	case video.FieldEosGeneratedThumbnails:
		return m.EosGeneratedThumbnails()
	case video.FieldCreatedAt:
		return m.CreatedAt()
	case video.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case video.FieldTitle:
		return m.OldTitle(ctx)
	case video.FieldDescription:
		return m.OldDescription(ctx)
	case video.FieldUploadDate:
		return m.OldUploadDate(ctx)
	case video.FieldUploader:
		return m.OldUploader(ctx)
	case video.FieldDuration:
		return m.OldDuration(ctx)
	case video.FieldViewCount:
		return m.OldViewCount(ctx)
	case video.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case video.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case video.FieldFormat:
		return m.OldFormat(ctx)
	case video.FieldWidth:
		return m.OldWidth(ctx)
	case video.FieldHeight:
		return m.OldHeight(ctx)
	case video.FieldResolution:
		return m.OldResolution(ctx)
	case video.FieldFps:
		return m.OldFps(ctx)
	case video.FieldAudioCodec:
		return m.OldAudioCodec(ctx)
	case video.FieldVideoCodec:
		return m.OldVideoCodec(ctx)
	case video.FieldAbr:
		return m.OldAbr(ctx)
	case video.FieldVbr:
		return m.OldVbr(ctx)
	case video.FieldEpoch:
		return m.OldEpoch(ctx)
	case video.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case video.FieldTags:
		return m.OldTags(ctx)
	case video.FieldCategories:
		return m.OldCategories(ctx)
	case video.FieldVideoPath:
		return m.OldVideoPath(ctx)
	case video.FieldThumbnailPath:
		return m.OldThumbnailPath(ctx)
	case video.FieldJSONPath:
		return m.OldJSONPath(ctx)
	case video.FieldCaptionPath:
		return m.OldCaptionPath(ctx)
	case video.FieldPath:
		return m.OldPath(ctx)
	case video.FieldThumbnailsPath:
		return m.OldThumbnailsPath(ctx)
	case video.FieldThumbnailsWidth:
		return m.OldThumbnailsWidth(ctx)
	case video.FieldThumbnailsHeight:
		return m.OldThumbnailsHeight(ctx)
	case video.FieldThumbnailsInterval:
		return m.OldThumbnailsInterval(ctx)
	case video.FieldThumbnailsRows:
		return m.OldThumbnailsRows(ctx)
	case video.FieldEosGeneratedThumbnails:
		return m.OldEosGeneratedThumbnails(ctx)
	case video.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case video.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Video field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case video.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case video.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case video.FieldUploadDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadDate(v)
		return nil
	case video.FieldUploader:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploader(v)
		return nil
	case video.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case video.FieldViewCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case video.FieldLikeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case video.FieldDislikeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case video.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case video.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case video.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case video.FieldResolution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolution(v)
		return nil
	case video.FieldFps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFps(v)
		return nil
	case video.FieldAudioCodec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioCodec(v)
		return nil
	case video.FieldVideoCodec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoCodec(v)
		return nil
	case video.FieldAbr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbr(v)
		return nil
	case video.FieldVbr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVbr(v)
		return nil
	case video.FieldEpoch:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpoch(v)
		return nil
	case video.FieldCommentCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case video.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case video.FieldCategories:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case video.FieldVideoPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoPath(v)
		return nil
	case video.FieldThumbnailPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailPath(v)
		return nil
	case video.FieldJSONPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJSONPath(v)
		return nil
	case video.FieldCaptionPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaptionPath(v)
		return nil
	case video.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case video.FieldThumbnailsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailsPath(v)
		return nil
	case video.FieldThumbnailsWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailsWidth(v)
		return nil
	case video.FieldThumbnailsHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailsHeight(v)
		return nil
	case video.FieldThumbnailsInterval:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailsInterval(v)
		return nil
	case video.FieldThumbnailsRows:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailsRows(v)
		return nil
	case video.FieldEosGeneratedThumbnails:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEosGeneratedThumbnails(v)
		return nil
	case video.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case video.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, video.FieldDuration)
	}
	if m.addview_count != nil {
		fields = append(fields, video.FieldViewCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, video.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, video.FieldDislikeCount)
	}
	if m.addwidth != nil {
		fields = append(fields, video.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, video.FieldHeight)
	}
	if m.addfps != nil {
		fields = append(fields, video.FieldFps)
	}
	if m.addabr != nil {
		fields = append(fields, video.FieldAbr)
	}
	if m.addvbr != nil {
		fields = append(fields, video.FieldVbr)
	}
	if m.addepoch != nil {
		fields = append(fields, video.FieldEpoch)
	}
	if m.addcomment_count != nil {
		fields = append(fields, video.FieldCommentCount)
	}
	if m.addthumbnails_width != nil {
		fields = append(fields, video.FieldThumbnailsWidth)
	}
	if m.addthumbnails_height != nil {
		fields = append(fields, video.FieldThumbnailsHeight)
	}
	if m.addthumbnails_interval != nil {
		fields = append(fields, video.FieldThumbnailsInterval)
	}
	if m.addthumbnails_rows != nil {
		fields = append(fields, video.FieldThumbnailsRows)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case video.FieldDuration:
		return m.AddedDuration()
	case video.FieldViewCount:
		return m.AddedViewCount()
	case video.FieldLikeCount:
		return m.AddedLikeCount()
	case video.FieldDislikeCount:
		return m.AddedDislikeCount()
	case video.FieldWidth:
		return m.AddedWidth()
	case video.FieldHeight:
		return m.AddedHeight()
	case video.FieldFps:
		return m.AddedFps()
	case video.FieldAbr:
		return m.AddedAbr()
	case video.FieldVbr:
		return m.AddedVbr()
	case video.FieldEpoch:
		return m.AddedEpoch()
	case video.FieldCommentCount:
		return m.AddedCommentCount()
	case video.FieldThumbnailsWidth:
		return m.AddedThumbnailsWidth()
	case video.FieldThumbnailsHeight:
		return m.AddedThumbnailsHeight()
	case video.FieldThumbnailsInterval:
		return m.AddedThumbnailsInterval()
	case video.FieldThumbnailsRows:
		return m.AddedThumbnailsRows()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case video.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case video.FieldViewCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case video.FieldLikeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case video.FieldDislikeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	case video.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case video.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case video.FieldFps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFps(v)
		return nil
	case video.FieldAbr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbr(v)
		return nil
	case video.FieldVbr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVbr(v)
		return nil
	case video.FieldEpoch:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpoch(v)
		return nil
	case video.FieldCommentCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case video.FieldThumbnailsWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThumbnailsWidth(v)
		return nil
	case video.FieldThumbnailsHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThumbnailsHeight(v)
		return nil
	case video.FieldThumbnailsInterval:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThumbnailsInterval(v)
		return nil
	case video.FieldThumbnailsRows:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThumbnailsRows(v)
		return nil
	}
	return fmt.Errorf("unknown Video numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(video.FieldDescription) {
		fields = append(fields, video.FieldDescription)
	}
	if m.FieldCleared(video.FieldDislikeCount) {
		fields = append(fields, video.FieldDislikeCount)
	}
	if m.FieldCleared(video.FieldFormat) {
		fields = append(fields, video.FieldFormat)
	}
	if m.FieldCleared(video.FieldWidth) {
		fields = append(fields, video.FieldWidth)
	}
	if m.FieldCleared(video.FieldHeight) {
		fields = append(fields, video.FieldHeight)
	}
	if m.FieldCleared(video.FieldResolution) {
		fields = append(fields, video.FieldResolution)
	}
	if m.FieldCleared(video.FieldFps) {
		fields = append(fields, video.FieldFps)
	}
	if m.FieldCleared(video.FieldAudioCodec) {
		fields = append(fields, video.FieldAudioCodec)
	}
	if m.FieldCleared(video.FieldVideoCodec) {
		fields = append(fields, video.FieldVideoCodec)
	}
	if m.FieldCleared(video.FieldAbr) {
		fields = append(fields, video.FieldAbr)
	}
	if m.FieldCleared(video.FieldVbr) {
		fields = append(fields, video.FieldVbr)
	}
	if m.FieldCleared(video.FieldEpoch) {
		fields = append(fields, video.FieldEpoch)
	}
	if m.FieldCleared(video.FieldCommentCount) {
		fields = append(fields, video.FieldCommentCount)
	}
	if m.FieldCleared(video.FieldTags) {
		fields = append(fields, video.FieldTags)
	}
	if m.FieldCleared(video.FieldCategories) {
		fields = append(fields, video.FieldCategories)
	}
	if m.FieldCleared(video.FieldCaptionPath) {
		fields = append(fields, video.FieldCaptionPath)
	}
	if m.FieldCleared(video.FieldThumbnailsPath) {
		fields = append(fields, video.FieldThumbnailsPath)
	}
	if m.FieldCleared(video.FieldThumbnailsWidth) {
		fields = append(fields, video.FieldThumbnailsWidth)
	}
	if m.FieldCleared(video.FieldThumbnailsHeight) {
		fields = append(fields, video.FieldThumbnailsHeight)
	}
	if m.FieldCleared(video.FieldThumbnailsInterval) {
		fields = append(fields, video.FieldThumbnailsInterval)
	}
	if m.FieldCleared(video.FieldThumbnailsRows) {
		fields = append(fields, video.FieldThumbnailsRows)
	}
	if m.FieldCleared(video.FieldEosGeneratedThumbnails) {
		fields = append(fields, video.FieldEosGeneratedThumbnails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMutation) ClearField(name string) error {
	switch name {
	case video.FieldDescription:
		m.ClearDescription()
		return nil
	case video.FieldDislikeCount:
		m.ClearDislikeCount()
		return nil
	case video.FieldFormat:
		m.ClearFormat()
		return nil
	case video.FieldWidth:
		m.ClearWidth()
		return nil
	case video.FieldHeight:
		m.ClearHeight()
		return nil
	case video.FieldResolution:
		m.ClearResolution()
		return nil
	case video.FieldFps:
		m.ClearFps()
		return nil
	case video.FieldAudioCodec:
		m.ClearAudioCodec()
		return nil
	case video.FieldVideoCodec:
		m.ClearVideoCodec()
		return nil
	case video.FieldAbr:
		m.ClearAbr()
		return nil
	case video.FieldVbr:
		m.ClearVbr()
		return nil
	case video.FieldEpoch:
		m.ClearEpoch()
		return nil
	case video.FieldCommentCount:
		m.ClearCommentCount()
		return nil
	case video.FieldTags:
		m.ClearTags()
		return nil
	case video.FieldCategories:
		m.ClearCategories()
		return nil
	case video.FieldCaptionPath:
		m.ClearCaptionPath()
		return nil
	case video.FieldThumbnailsPath:
		m.ClearThumbnailsPath()
		return nil
	case video.FieldThumbnailsWidth:
		m.ClearThumbnailsWidth()
		return nil
	case video.FieldThumbnailsHeight:
		m.ClearThumbnailsHeight()
		return nil
	case video.FieldThumbnailsInterval:
		m.ClearThumbnailsInterval()
		return nil
	case video.FieldThumbnailsRows:
		m.ClearThumbnailsRows()
		return nil
	case video.FieldEosGeneratedThumbnails:
		m.ClearEosGeneratedThumbnails()
		return nil
	}
	return fmt.Errorf("unknown Video nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMutation) ResetField(name string) error {
	switch name {
	case video.FieldTitle:
		m.ResetTitle()
		return nil
	case video.FieldDescription:
		m.ResetDescription()
		return nil
	case video.FieldUploadDate:
		m.ResetUploadDate()
		return nil
	case video.FieldUploader:
		m.ResetUploader()
		return nil
	case video.FieldDuration:
		m.ResetDuration()
		return nil
	case video.FieldViewCount:
		m.ResetViewCount()
		return nil
	case video.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case video.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case video.FieldFormat:
		m.ResetFormat()
		return nil
	case video.FieldWidth:
		m.ResetWidth()
		return nil
	case video.FieldHeight:
		m.ResetHeight()
		return nil
	case video.FieldResolution:
		m.ResetResolution()
		return nil
	case video.FieldFps:
		m.ResetFps()
		return nil
	case video.FieldAudioCodec:
		m.ResetAudioCodec()
		return nil
	case video.FieldVideoCodec:
		m.ResetVideoCodec()
		return nil
	case video.FieldAbr:
		m.ResetAbr()
		return nil
	case video.FieldVbr:
		m.ResetVbr()
		return nil
	case video.FieldEpoch:
		m.ResetEpoch()
		return nil
	case video.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case video.FieldTags:
		m.ResetTags()
		return nil
	case video.FieldCategories:
		m.ResetCategories()
		return nil
	case video.FieldVideoPath:
		m.ResetVideoPath()
		return nil
	case video.FieldThumbnailPath:
		m.ResetThumbnailPath()
		return nil
	case video.FieldJSONPath:
		m.ResetJSONPath()
		return nil
	case video.FieldCaptionPath:
		m.ResetCaptionPath()
		return nil
	case video.FieldPath:
		m.ResetPath()
		return nil
	case video.FieldThumbnailsPath:
		m.ResetThumbnailsPath()
		return nil
	case video.FieldThumbnailsWidth:
		m.ResetThumbnailsWidth()
		return nil
	case video.FieldThumbnailsHeight:
		m.ResetThumbnailsHeight()
		return nil
	case video.FieldThumbnailsInterval:
		m.ResetThumbnailsInterval()
		return nil
	case video.FieldThumbnailsRows:
		m.ResetThumbnailsRows()
		return nil
	case video.FieldEosGeneratedThumbnails:
		m.ResetEosGeneratedThumbnails()
		return nil
	case video.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case video.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.channel != nil {
		edges = append(edges, video.EdgeChannel)
	}
	if m.chapters != nil {
		edges = append(edges, video.EdgeChapters)
	}
	if m.comments != nil {
		edges = append(edges, video.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.chapters))
		for id := range m.chapters {
			ids = append(ids, id)
		}
		return ids
	case video.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchapters != nil {
		edges = append(edges, video.EdgeChapters)
	}
	if m.removedcomments != nil {
		edges = append(edges, video.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.removedchapters))
		for id := range m.removedchapters {
			ids = append(ids, id)
		}
		return ids
	case video.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchannel {
		edges = append(edges, video.EdgeChannel)
	}
	if m.clearedchapters {
		edges = append(edges, video.EdgeChapters)
	}
	if m.clearedcomments {
		edges = append(edges, video.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMutation) EdgeCleared(name string) bool {
	switch name {
	case video.EdgeChannel:
		return m.clearedchannel
	case video.EdgeChapters:
		return m.clearedchapters
	case video.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMutation) ClearEdge(name string) error {
	switch name {
	case video.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown Video unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMutation) ResetEdge(name string) error {
	switch name {
	case video.EdgeChannel:
		m.ResetChannel()
		return nil
	case video.EdgeChapters:
		m.ResetChapters()
		return nil
	case video.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown Video edge %s", name)
}
